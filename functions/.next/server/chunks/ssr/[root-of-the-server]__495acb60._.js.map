{"version":3,"sources":["turbopack:///[project]/src/lib/firebase/storage.ts"],"sourcesContent":["import { storage } from './client';\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport async function uploadPropertyImage(file: File, propertyId: string): Promise<string> {\n  const formData = new FormData();\n  formData.append('file', file);\n  formData.append('propertyId', propertyId);\n\n  // Try Firebase Storage first (preferred for production)\n  try {\n    console.log('üîÑ Trying Firebase Storage upload...');\n    const res = await fetch('/api/upload', { method: 'POST', body: formData });\n    if (res.ok) {\n      const data = await res.json();\n      console.log('‚úÖ Firebase Storage upload successful:', data.url);\n      return data.url as string;\n    } else {\n      const errorData = await res.json().catch(() => ({}));\n      console.warn('‚ùå Firebase Storage upload failed:', errorData);\n      throw new Error(`Firebase Storage failed: ${errorData.error || 'Unknown error'}`);\n    }\n  } catch (error) {\n    console.warn('‚ùå Firebase Storage upload error:', error);\n    \n    // Fallback to local upload only in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log('üîÑ Trying local upload as fallback (development only)...');\n      const res = await fetch('/api/upload-local', { method: 'POST', body: formData });\n      if (!res.ok) {\n        const err = await res.json().catch(() => ({}));\n        console.error('‚ùå Local upload failed:', err);\n        throw new Error(err?.error || 'All upload methods failed');\n      }\n      const data = await res.json();\n      console.log('‚úÖ Local upload successful:', data.url);\n      return data.url as string;\n    } else {\n      // In production, don't fallback to local upload\n      throw new Error('Firebase Storage upload failed and local upload is not available in production');\n    }\n  }\n}\n\nexport async function deletePropertyImage(imageUrl: string): Promise<void> {\n  try {\n    const imageRef = ref(storage, imageUrl);\n    await deleteObject(imageRef);\n  } catch (error) {\n    console.error('Error deleting image:', error);\n    // Don't throw error to prevent breaking the flow\n  }\n}\n\nexport async function deletePropertyImages(imageUrls: string[]): Promise<void> {\n  const deletePromises = imageUrls.map(url => deletePropertyImage(url));\n  await Promise.allSettled(deletePromises);\n}\n\n\n"],"names":[],"mappings":"6sBAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,CAAA,CAAA,MAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OAGO,eAAe,EAAoB,CAAU,CAAE,CAAkB,EACtE,IAAM,EAAW,IAAI,SACrB,EAAS,MAAM,CAAC,OAAQ,GACxB,EAAS,MAAM,CAAC,aAAc,GAG9B,GAAI,CACF,QAAQ,GAAG,CAAC,wCACZ,IAAM,EAAM,MAAM,MAAM,cAAe,CAAE,OAAQ,OAAQ,KAAM,CAAS,GACxE,GAAI,EAAI,EAAE,CAAE,CACV,IAAM,EAAO,MAAM,EAAI,IAAI,GAE3B,OADA,QAAQ,GAAG,CAAC,wCAAyC,EAAK,GAAG,EACtD,EAAK,GACd,AADiB,CACV,CACL,IAAM,EAAY,MAAM,EAAI,IAAI,GAAG,KAAK,CAAC,IAAM,CAAC,EAAC,CAAC,CAElD,OADA,QAAQ,IAAI,CAAC,oCAAqC,GAC5C,AAAI,MAAM,CAAC,yBAAyB,EAAE,EAAU,KAAK,EAAI,gBAAA,CAAiB,CAClF,CACF,CAAE,MAAO,EAAO,CAiBZ,MAhBF,QAAQ,IAAI,CAAC,mCAAoC,GAgBzC,AAAI,MAAM,iFAEpB,CACF,CAEO,eAAe,EAAoB,CAAgB,EACxD,GAAI,CACF,IAAM,EAAW,CAAA,EAAA,EAAA,GAAA,AAAG,EAAC,EAAA,OAAO,CAAE,EAC9B,OAAM,CAAA,EAAA,EAAA,YAAA,AAAY,EAAC,EACrB,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,wBAAyB,EAEzC,CACF,CAEO,eAAe,EAAqB,CAAmB,EAC5D,IAAM,EAAiB,EAAU,GAAG,CAAC,GAAO,EAAoB,GAChE,OAAM,QAAQ,UAAU,CAAC,EAC3B"}